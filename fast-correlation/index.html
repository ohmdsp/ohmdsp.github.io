<!doctype html><html lang=en-us><head><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no,viewport-fit=cover"><meta charset=utf-8><meta name=generator content="Hugo 0.123.7 with Arberia theme"><title>OhmDSP Site | Fast Correlation</title>
<link rel=canonical href=https://ohmdsp.github.io/fast-correlation/><meta name=description content="Descrizione da rivedere se è un doppione subtitle"><meta name=author content><meta name=keywords content><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","headline":"Fast Correlation","datePublished":"2019-12-01T21:57:40+08:00","dateModified":"2019-12-01T21:57:40+08:00","url":"https://ohmdsp.github.io/fast-correlation/","description":"Descrizione da rivedere se è un doppione subtitle","keywords":["Correlation","FFT","Convolution"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ohmdsp.github.io/"},"publisher":{"@type":"Organization","name":"OhmDSP Site","url":"https://ohmdsp.github.io/"}}</script><link rel=icon href=../favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=../favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=../favicon/favicon-32x32.png><link rel=apple-touch-icon href=../favicon/apple-touch-icon.png><link rel=mask-icon href=../favicon/safari-pinned-tab.svg><link rel=manifest href=../site.webmanifest><meta name=theme-color content="/"><meta name=msapplication-TileColor content="/"><link rel=stylesheet type=text/css href=../lib/bootstrap/css/bootstrap.min.css><link rel=stylesheet type=text/css href=../lib/lightbox/css/lightbox.css><link rel=stylesheet type=text/css href=../font-awesome-4.7.0/css/font-awesome.min.css><link rel=stylesheet type=text/css href=../gfonts/font.css><link rel=stylesheet href=https://ohmdsp.github.io/main.min.cd0e89a060caa38dbb22a636944f6f5546d4650fcb33393f71de3295fd988348.css><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"],processHtmlClass:"mathjax",ignoreHtmlClass:"no-mathjax"}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><nav class="navbar fixed-top navbar-expand-lg navbar-dark flex-column"><div class="container flex-row"><style>.navbar-brand{color:#fff!important;font-weight:700!important}</style><button class="navbar-toggler mr-3" type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse navbar-nav-scroll" id=navbarSupportedContent role=navigation aria-label="Main Navigation"><ul class="navbar-nav mr-5 flex-fill"><li class=nav-item><a class=nav-link href=../posts/>OhmDSP Blog</a></li><li class=nav-item><a class=nav-link href=../about/>About</a></li></ul><div class="collapse navbar-collapse navbar-nav-scroll" id=navbarSupportedContent role=navigation aria-label="Main Navigation"><div class="d-block d-lg-none"><ul class=navbar-nav><li class=nav-item><a class=nav-link href=../search title=Search><span class="d-block d-lg-none"><i class="fa fa-search" aria-hidden=true></i> Search</span><span class="d-none d-lg-block"><i class="fa fa-search" aria-hidden=true></i></span></a></li></ul></div><div class="d-none d-lg-flex align-items-center mr-2 flex-fill"><form class="form-inline ml-0" action=../search method=GET target=_self><a class="js-search-form-submit position-absolute" href=../search title=Search><i class="fa fa-search fa-fw text-muted pl-2" aria-hidden=true></i></a>
<input id=search-by class="search-field form-control form-control-md mr-sm-1 mr-lg-2 w-100" style=padding-left:2rem maxlength=50 data-search-input type=search placeholder=Search aria-label=Search name=q>
<input type=hidden name=_from value=nav></form></div></div></div></nav><div class="container main-content"><div class="row justify-content-center"><div class="col-md-10 col-lg-8 article"><div class="article-body page-body"><h1 class=text-center id=post-title>Fast Correlation<a class=headerlink href=../fast-correlation/ title="Permanent link"></a></h1><p class="text-center text-muted">Use those FFTs</p><picture><source media=(min-width:480px) srcset=../fast-correlation/fastcorr_main_hu36cec492f83f7af7185851a6229069e0_166012_960x0_resize_q75_h2_box.webp type=image/webp><source srcset=../fast-correlation/fastcorr_main_hu36cec492f83f7af7185851a6229069e0_166012_480x0_resize_q75_h2_box.webp type=image/webp><img loading=lazy class="img-fluid mx-auto d-block rounded mb-4" src=../fast-correlation/fastcorr_main.jpg height=1080 width=1920 type=image/jpeg alt=fastcorr_main.jpg></picture><div class="row mb-1"><div class="col-2 col-md-1 p-0 ml-3 align-self-center"><a href><img src class="rounded-circle img-fluid w-100" sizes=10vw alt></a></div><div class="col pr-0 d-flex align-items-center"><p><span class=text-muted><span class=mr-2><a class=text-muted href target=_blank></a></span><br><span class="fa fa-clock-o"></span> <time>Dec 1, 2019</time>
<span class="ml-2 fa fa-tags" aria-hidden=true></span>
<a class="badge badge-light text-muted" href=../tags/correlation/>Correlation</a>
<span class="ml-2 fa fa-tags" aria-hidden=true></span>
<a class="badge badge-light text-muted" href=../tags/fft/>FFT</a>
<span class="ml-2 fa fa-tags" aria-hidden=true></span>
<a class="badge badge-light text-muted" href=../tags/convolution/>Convolution</a></span></p></div></div><p>There are two methods for computing the correlation of complex-valued signals. The first one is a time-domain method, and for a stationary process can be computed using the following formula</p><p>$$
r(k) =
\begin{cases}
\frac{1}{N} \sum^{N-k-1}_{n=0} x(n+k)h^{\ast}(n) & \text{if } 0 \leq k \leq N-1 \\
r^{\ast}(-k) & \text{if } -(N-1) \leq k \lt 0 \\
0 & \text{if } elsewhere
\end{cases}
$$</p><p>where N is the input data record length, x(n) is the input data and h(n) is the kernel, or reference data. The computational time to compute a correlation using this method is directly proportional to the number of samples in the kernel. Therefore, the longer the kernel data record the more time it takes to compute a correlation.</p><p>The second method for computing a correlation is a frequency domain method called “fast correlation”. Fast correlation uses the Fast Fourier Transform (FFT) to transform the input signal and the kernel signal into the frequency domain and then exploits the following mathematical relationship
$$ x(n) \circledast h(n) = ifft {X(k)*conj(Y(k))} $$</p><p>It is well known that when dealing with kernel lengths that are greater than about 60 samples it is faster, or more efficient, to use the fast correlation method. To the fact that the time it takes to compute the fast correlation is proportional to the logarithm of the number of samples, and therefore, changes slowly as the kernel length increases. Figure 1 shows a computation time comparison between the time-domain and fast correlation methods versus kernel length, or “impulse response length”.</p><figure><img src=../images/fastcorr_eff.png style=width:460px;height:320px><figcaption>Figuer 1. Execution times for fast correlation compared to time-domain correlation [Steven W. Smith,DSP Guide].</figcaption></figure><p>It is often useful to look at a pictorial representation of an algorithm. A block diagram showing the processing steps involved in computing the fast correlation is shown in Figure 2. It is worth mentioning that fast correlation is also called “pulse compression” in the radar community. Therefore, it should be no surprise to learn that many commercially available technologies, both hardware and software, are available to implement it.</p><figure><img src=../images/fastcorr_block.png style=width:640px;height:320px><figcaption>Figuer 2. Block diagram showing the processing steps for computing frequency-domain correlation.</figcaption></figure><p>The most efficient way to implement fast correlation for very long input data sequences is to use the overlap “scrap” (OVS) algorithm, also known as the overlap-save algorithm. The overlap-save algorithm can be easily understood by looking at the sample sequences x and h in Figure 3. First, the input data sequence is broken up into arbitrary segments of length N. Then, each segment is processed using the fast correlation method discussed in the last section. However, special segment overlapping and data discarding rules must be by followed in order to avoid wrap-around pollution in the output sequence. We will not go into an analysis of wrap-around pollution in this report since most DSP textbooks cover it in detail. The OVS algorithm can be implemented by following these steps:</p><ol><li>Zero pad the kernel out to the FFT length (N) to avoid wrap-around pollution</li><li>Add M-1 zeros to the beginning of the input data and N-1 zeros to the end</li><li>Break input signal into successive segments of N samples, each segment overlapping the previous segment by M-1 samples</li><li>Compute the FFT of the kernel and complex conjugate (save for reuse)</li><li>Buffer a segment of input signal and compute the FFT</li><li>Multiply (element- wise) outputs from steps 4 and 5</li><li>Compute the inverse FFT (IFFT) from output of multiply</li><li>Last M-1 samples of each IFFT output are discarded, (front M-1 samples discarded from first output block)</li><li>The remaining samples are used as output</li><li>Steps 5-9 are repeated until all input segments used</li></ol><figure><img src=../images/corr_example.png style=width:540px;height:220px><figcaption>Simple Overlap "Scrap" algorithm example.</figcaption></figure><figure><img src=../images/corr_matlab_plot.png style=width:540px;height:320px><figcaption>Plots from simple example.</figcaption></figure><p>It is important to note that the last M-1 samples of each IFFT output should be discarded instead of the front M-1 samples. This will help in the implementation by avoiding double buffering at the output of the IFFT. Matlab code for simulating the OVS correlation algorithm is included below.</p><p>Usually we would consider the following factors when deciding the overlap amount for the OVS algorithm.</p><ol><li>FFT Accuracy – the numerical accuracy of fast correlation is dependent on the error introduced by the FFT and IFFT process. For floating point implementations this is usually negligible, but for fixed point processing, significant dynamic range can be lost when using larger transforms.</li><li>Latency – the fast correlation process extends the group delay by at least N samples. So, the longer the FFT, the longer the latency.
In the absence of a benchmark, an overlap factor of 4 to 8 is a good rule of thumb. Since we do not have a lot of flexibility when choosing a kernel size, we will need to choose the length of the FFT to give optimal performance.</li></ol><pre tabindex=0><code>% Filename: overlap_scrap_corr.m &lt;br&gt;
% Author: drohm &lt;br&gt;
% &lt;br&gt;
% y = output sequence &lt;br&gt;
% x = input sequence &lt;br&gt;
% h = kernel sequence &lt;br&gt;
% N = segment length &amp; fft length &lt;br&gt;
% Implements overlap-scrap (OVS) &#34;overlap-save&#34; correlation. &lt;br&gt;
%========================================================================== %========================================================================== 
clear all;close all &lt;br&gt;
x1 = [zeros(1,128)+j*zeros(1,128)];   %Input Data &lt;br&gt;
h1 = [ 1 0 1 1 0 1];                  %Kernel&lt;br&gt;
Lenx = length(x1); M = length(h1); &lt;br&gt;
x1(25:25+M-1)=h1;                     %Embed Kernel into nput data&lt;br&gt;

xp = [x1 zeros(1,length(h1)-1)];      %Zero Padded input sequence and Kernel&lt;br&gt;
hp = [h1 zeros(1,length(x1)-1)];&lt;br&gt;

N=8; % Segment Size and FFT Size for OVS &lt;br&gt;
M1 = M-1; L = N-M1;&lt;br&gt;
h = [h1 zeros(1,N-M)];&lt;br&gt;
Leny = Lenx + M -1; %Length of final correlation output &lt;br&gt;

x = [zeros(1,M-1), x1, zeros(1,N-1)];
K = floor((Lenx+M1-1)/(L)); % # of segment sent to correlator&lt;br&gt;
Y = zeros(K+1,N); % Allocate output 2D array of zeros&lt;br&gt;

%%%%% Correlator %%%%%&lt;br&gt;
% These steps perform the correlation using the FFT&lt;br&gt;
for k=0:K &lt;br&gt;
  xk = x(k*(N-(M-1))+1:k*(N-(M-1))+N); % Input segments&lt;br&gt;
  Y(k+1,:) = ifft( (fft(xk,N).*conj(fft(h,N))),N ); % FFT Correlation&lt;br&gt;
end&lt;br&gt;
Y = Y(:,1:N-(M-1))&#39;; %discard the last (M-1) samples&lt;br&gt;
y = (Y(:))&#39;; % assemble output into 1D array&lt;br&gt;
y = (real(y(M-1:Leny))); %remove extra zeros at end&lt;br&gt;

%%%%% Plotting %%%%%&lt;br&gt;
figure(1)&lt;br&gt;
subplot(4,1,1)&lt;br&gt;
stem(x1);title(&#39;Input Data&#39;);ylim([0,2])&lt;br&gt;
subplot(4,1,2)&lt;br&gt;
stem(h1);title(&#39;Kernel Data&#39;);ylim([0,2])&lt;br&gt;
subplot(4,1,3)&lt;br&gt;
stem(y);title(&#39;Output (OVS)&#39;);ylim([0,5])&lt;br&gt;
</code></pre></div></div></div></div><footer class=footer><div class=container><p class="small text-center text-muted w-75 mx-auto">&copy 2012–2025 OhmDSP Site&nbsp;⋅
<a href=../contact>Contact</a>&nbsp;</div></footer><script type=text/javascript src=../lib/jquery/jquery.js></script><script type=text/javascript src=../lib/popper/popper.js></script><script type=text/javascript src=../lib/bootstrap/js/bootstrap.min.js></script><script type=text/javascript src=../lib/lightbox/js/lightbox.js></script><script>var lightbox=GLightbox(),lightboxDescription,lightboxVideo,lightboxInlineIframe;lightbox.on("open",e=>{console.log("lightbox opened")}),lightboxDescription=GLightbox({selector:".glightbox2"}),lightboxVideo=GLightbox({selector:".glightbox3"}),lightboxVideo.on("slide_changed",({prev:e,current:t})=>{console.log("Prev slide",e),console.log("Current slide",t);const{slideIndex:s,slideNode:o,slideConfig:i,player:n}=t;n&&(n.ready||n.on("ready",e=>{}),n.on("play",e=>{console.log("Started play")}),n.on("volumechange",e=>{console.log("Volume change")}),n.on("ended",e=>{console.log("Video ended")}))}),lightboxInlineIframe=GLightbox({selector:".glightbox4"})</script><script type=text/javascript src=../lib/back-to-top/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:56,backgroundColor:"rgb(255, 82, 82)",textColor:"#fff"})</script></body></html>